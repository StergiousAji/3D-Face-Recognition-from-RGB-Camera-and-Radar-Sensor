import sys
import struct
from types import SimpleNamespace

import matplotlib.pyplot as plt
import numpy as np

class SoliLogParser:

    OLD_HEADER_STRUCT = struct.Struct('<III')
    HEADER_STRUCT = struct.Struct('<4sHBI')
    PROFILE_STRUCT = struct.Struct('<B5I')
    BURST_STRUCT = struct.Struct('<dII')

    PROFILES = {
        0: 'default',
        1: 'short range',
        2: 'long range',
            }

    def __init__(self):
        self._params = None
        self._samples_struct = None
        self._chunk_size = None
        self._last_burst_id = 0

    def parse_burst(self, burstdata, clear_params=False):
        """Parses a single packet (=1 burst) sent by simplelogger in streaming mode"""
        
        if self._params is None or clear_params:
            print('*** Parsing parameters from burst')
            marker, header_size, header_version, num_channels = SoliLogParser.HEADER_STRUCT.unpack(burstdata[:SoliLogParser.HEADER_STRUCT.size])
            params = SimpleNamespace(num_channels=num_channels)
            burstdata = burstdata[SoliLogParser.HEADER_STRUCT.size:]
            params.profile_id, params.lower_freq, params.upper_freq, params.chirp_rate, params.chirps_per_burst, params.samples_per_chirp = SoliLogParser.PROFILE_STRUCT.unpack(burstdata[:SoliLogParser.PROFILE_STRUCT.size])
            params.profile = SoliLogParser.PROFILES[params.profile_id]
            self._params = params
            self._last_burst_id = 0

            self._samples_struct = struct.Struct('<' + 'f' * self._params.samples_per_chirp)

            self._chunk_size = SoliLogParser.BURST_STRUCT.size
            self._chunk_size += 4 * params.num_channels * params.samples_per_chirp * params.chirps_per_burst
            data = burstdata[SoliLogParser.PROFILE_STRUCT.size:]
        else:
            data = burstdata[SoliLogParser.HEADER_STRUCT.size + SoliLogParser.PROFILE_STRUCT.size:]

        if len(data) != self._chunk_size:
            if len(data) > 0:
                raise Exception('Warning, partial read! Expected {} bytes, read {}'.format(self._chunk_size, len(data)))

        timestamp, burst_id, burst_timestamp_ms = SoliLogParser.BURST_STRUCT.unpack(data[:SoliLogParser.BURST_STRUCT.size])
        if self._last_burst_id > 0 and burst_id != (self._last_burst_id + 1):
            print('Warning: expected burst ID {}, found burst ID {}'.format(self._last_burst_id + 1, burst_id))
        self._last_burst_id = burst_id

        data = data[SoliLogParser.BURST_STRUCT.size:]

        chirps = []
        for ci in range(self._params.chirps_per_burst):
            chirp_data = np.zeros((0, self._params.samples_per_chirp), dtype=np.float32)
            for channel in range(self._params.num_channels):
                chirp_data = np.vstack((chirp_data, np.array(self._samples_struct.unpack(data[:self._samples_struct.size]), dtype=np.float32)))
                data = data[self._samples_struct.size:]
            chirps.append(chirp_data)

        if len(chirps) != self._params.chirps_per_burst:
            raise Exception('Found {} chirps in burst ID {}, expected {}'.format(len(chirps), burst_id, self._params.chirps_per_burst))

        return self._params, SimpleNamespace(timestamp=timestamp, burst_id=burst_id, burst_timestamp_ms=burst_timestamp_ms, chirps=chirps)

    def parse_file(self, filename):
        """Parses a file generated by simplelogger"""
        params = SimpleNamespace(filename=filename)

        with open(filename, 'rb') as f:
            # assume we have new header
            marker, header_size, header_version, num_channels = SoliLogParser.HEADER_STRUCT.unpack(f.read(SoliLogParser.HEADER_STRUCT.size))
            
            if marker != b'soli':
                print('WARNING: found old-style header')
                f.seek(0)
                # read the small header giving the burst configuration
                chirps_per_burst, samples_per_chirp, num_channels = SoliLogParser.OLD_HEADER_STRUCT.unpack(f.read(SoliLogParser.OLD_HEADER_STRUCT.size))
                params = SimpleNamespace(chirps_per_burst=chirps_per_burst, samples_per_chirp=samples_per_chirp, num_channels=num_channels)
                params.lower_freq = 0
                params.upper_freq = 0
                params.chirp_rate = 0
            else:
                print('New-style header found, size = {:d} bytes, version = {}'.format(header_size, header_version))
                params = SimpleNamespace(num_channels=num_channels)
                params.profile_id, params.lower_freq, params.upper_freq, params.chirp_rate, params.chirps_per_burst, params.samples_per_chirp = SoliLogParser.PROFILE_STRUCT.unpack(f.read(SoliLogParser.PROFILE_STRUCT.size))
                params.profile = SoliLogParser.PROFILES[params.profile_id]

            chunk_size = SoliLogParser.BURST_STRUCT.size
            chunk_size += 4 * params.num_channels * params.samples_per_chirp * params.chirps_per_burst

            samples_struct = struct.Struct('<' + 'f' * params.samples_per_chirp)
            # now iterate until end of file, should only retain complete bursts,
            # so ignore any partial data at the end
            bursts = []
            last_burst_id = -1

            while True:
                data = f.read(chunk_size)
                if len(data) != chunk_size:
                    if len(data) > 0:
                        print('Warning, partial read! Expected {} bytes, read {}'.format(chunk_size, len(data)))
                    break

                timestamp, burst_id, burst_timestamp_ms = SoliLogParser.BURST_STRUCT.unpack(data[:SoliLogParser.BURST_STRUCT.size])
                if last_burst_id > 0 and burst_id != (last_burst_id + 1):
                    print('Warning: expected burst ID {}, found burst ID {}'.format(last_burst_id + 1, burst_id))
                last_burst_id = burst_id

                data = data[SoliLogParser.BURST_STRUCT.size:]

                chirps = []
                for ci in range(params.chirps_per_burst):
                    chirp_data = np.zeros((0, params.samples_per_chirp), dtype=np.float32)
                    for channel in range(params.num_channels):
                        chirp_data = np.vstack((chirp_data, np.array(samples_struct.unpack(data[:samples_struct.size]), dtype=np.float32)))
                        data = data[samples_struct.size:]
                    chirps.append(chirp_data)

                if len(chirps) != params.chirps_per_burst:
                    raise Exception('Found {} chirps in burst ID {}, expected {}'.format(len(chirps), burst_id, params.chirps_per_burst))

                bursts.append(SimpleNamespace(timestamp=timestamp, burst_id=burst_id, burst_timestamp_ms=burst_timestamp_ms, chirps=chirps))

            return params, bursts

def get_rp_data_bin(bursts):
    rp_data = []

    # n_rbins and window were previously calculated on each call to compute_rp_complex
    # but they only depend on the chirp length which will be the same for every
    # chirp in a burst, so just calculate them once here to make things a bit faster
    n_rbins = bursts[0].chirps[0][0, :].shape[0]
    window = np.blackman(n_rbins).astype(np.float32)
    window /= np.linalg.norm(window)

    for burst in bursts:
        for chirp in burst.chirps:
            rp_chirp = []
            for channel in range(3):
                rp_chirp.append(compute_rp_complex(chirp[channel, :], n_rbins, window))
            rp_data.append(rp_chirp)
    return np.asarray(rp_data)

def get_crd_data_bin(params, bursts, clutter_coeff=0, remove_clutter_=False):
    rp_data = get_rp_data_bin(bursts)
    if remove_clutter_:
        rp_clutter = remove_clutter(rp_data, clutter_coeff)
    else:
        rp_clutter = rp_data

    num_chirps_per_burst = params.chirps_per_burst
    
    window = np.blackman(num_chirps_per_burst).astype(np.float32)
    window /= np.linalg.norm(window)

    rp_transposed = np.transpose(rp_clutter, (1, 0, 2))
    result = []
    for channel_data in rp_transposed:
        channel_data = np.reshape(channel_data, (channel_data.shape[0] // num_chirps_per_burst, num_chirps_per_burst, channel_data.shape[1]))
        crp_per_channel = []
        for burst in channel_data:
            burst = np.transpose(burst)
            crp_burst = []
            for data in burst:
                data = data * window
                data = np.fft.fft(data)
                crp_burst.append(data)
            crp_burst = np.asarray(crp_burst)
            crp_per_channel.append(crp_burst)
        crp_per_channel = np.asarray(crp_per_channel)
        result.append(crp_per_channel)
    result = np.asarray(result)
    result = np.transpose(result, (1, 0, 2, 3))
    result = np.roll(result, result.shape[3]//2, axis=3)
    return result

#
# these methods taken from "Soli Radar Data processing" Colab
#

# Range profile (aka preprocessed)
def compute_rp_complex(chirp_raw, n_rbins, window, zpf=1):
    # range processing
    chirp_raw *= window
    chirp_raw = chirp_raw - np.mean(chirp_raw)
    rp_complex = np.fft.fft(chirp_raw, n=n_rbins * zpf)[:int(n_rbins * zpf / 2)] / n_rbins
    return rp_complex

def get_rp_data(json_data):
    rp_data = list()
    for burst in json_data['bursts']:
        for chirp in burst['chirps']:
            rp_chirp = list()
            for channel_data in chirp['channels_data']:
                chirp = channel_data['values']
                chirp = np.asarray(chirp)
                rp_chirp.append(compute_rp_complex(chirp))
            rp_data.append(rp_chirp)
    return np.asarray(rp_data)

def remove_clutter(range_data, clutter_alpha):
    assert range_data.ndim == 3
    clutter_map = 0
    nchirp, nchan, szr = range_data.shape
    range_clutter = range_data.copy()
    if clutter_alpha != 0:
        clutter_map = range_data[0]
        for ic in range(1, nchirp):
            clutter_map = (clutter_map * clutter_alpha + range_data[ic, ...] * (1.0 - clutter_alpha))
            range_clutter[ic, ...] -=  clutter_map
    return range_clutter

def get_chirp_timestamps(json_data):
    timestamps = []
    request_rate = 2000.0
    for burst in json_data['bursts']:
        for chirp in burst['chirps']:
            if 'timestamp_ms' in chirp:
                timestamps.append(chirp['timestamp_ms'])
            else:
                timestamps.append(burst['timestamp_ms'] + + (chirp['chirp_id'] - 1) * (1000.0 * 1.0 / request_rate))
    return np.asarray(timestamps)

def get_crd_data(rp_data, clutter_coeff=0.9, num_chirps_per_burst=16):
    rp_clutter = remove_clutter(rp_data, clutter_coeff)

    window = np.blackman(num_chirps_per_burst).astype(np.float32)
    window /= np.linalg.norm(window)

    rp_transposed = np.transpose(rp_clutter, (1, 0, 2))
    result = []
    for channel_data in rp_transposed:
        channel_data = np.reshape(channel_data, (channel_data.shape[0] // num_chirps_per_burst, num_chirps_per_burst, channel_data.shape[1]))
        crp_per_channel = []
        for burst in channel_data:
            burst = np.transpose(burst)
            crp_burst = []
            for data in burst:
                data = data * window
                data = np.fft.fft(data)
                crp_burst.append(data)
            crp_burst = np.asarray(crp_burst)
            crp_per_channel.append(crp_burst)
        crp_per_channel = np.asarray(crp_per_channel)
        result.append(crp_per_channel)
    result = np.asarray(result)
    result = np.transpose(result,(1, 0, 2, 3))
    result = np.roll(result, result.shape[3], axis=3)
    return result


def plot_crd_data(crd_data, indices=None):
    num_channels = crd_data.shape[1]

    if indices is not None:
        crd_data = crd_data[indices]

    print('Plotting {} frames'.format(crd_data.shape[0]))
    for frame_crd in crd_data:
        plt.figure(figsize=(24, 8))
        for channel_id in range(num_channels):  
            fig = plt.subplot(1, num_channels, channel_id + 1)
            plt.imshow(np.abs(frame_crd[channel_id,:,:]), origin='lower', cmap=plt.get_cmap('jet'), interpolation='none', aspect='equal')
            plt.title('ch' + str(channel_id))
            plt.grid(False)
    plt.tight_layout()
    plt.grid(False)
    plt.show()

# doesn't seem to work for .radar files?
def plot_abs_data(data):
    for channel_idx in range(data.shape[1]):
        fig = plt.figure(figsize=(6, 2), dpi=300)
        ax = fig.add_subplot(111)
        plt.imshow(np.abs(data[:, channel_idx, :].transpose()), origin='lower', cmap=plt.get_cmap('jet'), interpolation='none', aspect='auto')
        plt.colorbar()
        plt.tight_layout()
        plt.grid(False)
        plt.show()

if __name__ == "__main__":
    params, bursts = SoliLogParser().parse_file(sys.argv[1])
    print(params)
    # plot_crd_data(get_crd_data_bin(params, bursts), indices=[x for x in range(100, 200, 5)])
